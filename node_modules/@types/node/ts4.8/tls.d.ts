/**
 * The `tls` module provides an implementation of the Transport Layer Security
 * (TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL.
 * The module can be accessed using:
 *
 * ```js
 * const tls = require('tls');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/tls.js)
 */
declare module 'tls' {
    import { X509Certificate } from 'node:crypto';
    import * as net from 'node:net';
    import * as stream from 'stream';
    const CLIENT_RENEG_LIMIT: number;
    const CLIENT_RENEG_WINDOW: number;
    interface Certificate {
        /**
         * Country code.
         */
        C: string;
        /**
         * Street.
         */
        ST: string;
        /**
         * Locality.
         */
        L: string;
        /**
         * Organization.
         */
        O: string;
        /**
         * Organizational unit.
         */
        OU: string;
        /**
         * Common name.
         */
        CN: string;
    }
    interface PeerCertificate {
        /**
         * `true` if a Certificate Authority (CA), `false` otherwise.
         * @since v18.13.0
         */
        ca: boolean;
        /**
         * The DER encoded X.509 certificate data.
         */
        raw: Buffer;
        /**
         * The certificate subject.
         */
        subject: Certificate;
        /**
         * The certificate issuer, described in the same terms as the `subject`.
         */
        issuer: Certificate;
        /**
         * The date-time the certificate is valid from.
         */
        valid_from: string;
        /**
         * The date-time the certificate is valid to.
         */
        valid_to: string;
        /**
         * The certificate serial number, as a hex string.
         */
        serialNumber: string;
        /**
         * The SHA-1 digest of the DER encoded certificate.
         * It is returned as a `:` separated hexadecimal string.
         */
        fingerprint: string;
        /**
         * The SHA-256 digest of the DER encoded certificate.
         * It is returned as a `:` separated hexadecimal string.
         */
        fingerprint256: string;
        /**
         * The SHA-512 digest of the DER encoded certificate.
         * It is returned as a `:` separated hexadecimal string.
         */
        fingerprint512: string;
        /**
         * The extended key usage, a set of OIDs.
         */
        ext_key_usage?: string[];
        /**
         * A string containing concatenated names for the subject,
         * an alternative to the `subject` names.
         */
        subjectaltname?: string;
        /**
         * An array describing the AuthorityInfoAccess, used with OCSP.
         */
        infoAccess?: NodeJS.Dict<string[]>;
        /**
         * For RSA keys: The RSA bit size.
         *
         * For EC keys: The key size in bits.
         */
        bits?: number;
        /**
         * The RSA exponent, as a string in hexadecimal number notation.
         */
        exponent?: string;
        /**
         * The RSA modulus, as a hexadecimal string.
         */
        modulus?: string;
        /**
         * The public key.
         */
        pubkey?: Buffer;
        /**
         * The ASN.1 name of the OID of the elliptic curve.
         * Well-known curves are identified by an OID.
         * While it is unusual, it is possible that the curve
         * is identified by its mathematical properties,
         * in which case it will not have an OID.
         */
        asn1Curve?: string;
        /**
         * The NIST name for the elliptic curve,if it has one
         * (not all well-known curves have been assigned names by NIST).
         */
        nistCurve?: string;
    }
    interface DetailedPeerCertificate extends PeerCertificate {
        /**
         * The issuer certificate object.
         * For self-signed certificates, this may be a circular reference.
         */
        issuerCertificate: DetailedPeerCertificate;
    }
    interface CipherNameAndProtocol {
        /**
         * The cipher name.
         */
        name: string;
        /**
         * SSL/TLS protocol version.
         */
        version: string;
        /**
         * IETF name for the cipher suite.
         */
        standardName: string;
    }
    interface EphemeralKeyInfo {
        /**
         * The supported types are 'DH' and 'ECDH'.
         */
        type: string;
        /**
         * The name property is available only when type is 'ECDH'.
         */
        name?: string | undefined;
        /**
         * The size of parameter of an ephemeral key exchange.
         */
        size: number;
    }
    interface KeyObject {
        /**
         * Private keys in PEM format.
         */
        pem: string | Buffer;
        /**
         * Optional passphrase.
         */
        passphrase?: string | undefined;
    }
    interface PxfObject {
        /**
         * PFX or PKCS12 encoded private key and certificate chain.
         */
        buf: string | Buffer;
        /**
         * Optional passphrase.
         */
        passphrase?: string | undefined;
    }
    interface TLSSocketOptions extends SecureContextOptions, CommonConnectionOptions {
        /**
         * If true the TLS socket will be instantiated in server-mode.
         * Defaults to false.
         */
        isServer?: boolean | undefined;
        /**
         * An optional net.Server instance.
         */
        server?: net.Server | undefined;
        /**
         * An optional Buffer instance containing a TLS session.
         */
        session?: Buffer | undefined;
        /**
         * If true, specifies that the OCSP status request extension will be
         * added to the client hello and an 'OCSPResponse' event will be
         * emitted on the socket before establishing a secure communication
         */
        requestOCSP?: boolean | undefined;
    }
    /**
     * Performs transparent encryption of written data and all required TLS
     * negotiation.
     *
     * Instances of `tls.TLSSocket` implement the duplex `Stream` interface.
     *
     * Methods that return TLS connection metadata (e.g.{@link TLSSocket.getPeerCertificate} will only return data while the
     * connection is open.
     * @since v0.11.4
     */
    class TLSSocket extends net.Socket {
        /**
         * Construct a new tls.TLSSocket object from an existing TCP socket.
         */
        constructor(socket: net.Socket, options?: TLSSocketOptions);
        /**
         * This property is `true` if the peer certificate was signed by one of the CAs
         * specified when creating the `tls.TLSSocket` instance, otherwise `false`.
         * @since v0.11.4
         */
        authorized: boolean;
        /**
         * Returns the reason why the peer's certificate was not been verified. This
         * property is set only when `tlsSocket.authorized === false`.
         * @since v0.11.4
         */
        authorizationError: Error;
        /**
         * Always returns `true`. This may be used to distinguish TLS sockets from regular`net.Socket` instances.
         * @since v0.11.4
         */
        encrypted: true;
        /**
         * String containing the selected ALPN protocol.
         * Before a handshake has completed, this value is always null.
         * When a handshake is completed but not ALPN protocol was selected, tlsSocket.alpnProtocol equals false.
         */
        alpnProtocol: string | false | null;
        /**
         * Returns an object representing the local certificate. The returned object has
         * some properties corresponding to the fields of the certificate.
         *
         * See {@link TLSSocket.getPeerCertificate} for an example of the certificate
         * structure.
         *
         * If there is no local certificate, an empty object will be returned. If the
         * socket has been destroyed, `null` will be returned.
         * @since v11.2.0
         */
        getCertificate(): PeerCertificate | object | null;
        /**
         * Returns an object containing information on the negotiated cipher suite.
         *
         * For example:
         *
         * ```json
         * {
         *     "name": "AES128-SHA256",
         *     "standardName": "TLS_RSA_WITH_AES_128_CBC_SHA256",
         *     "version": "TLSv1.2"
         * }
         * ```
         *
         * See [SSL\_CIPHER\_get\_name](https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name.html) for more information.
         * @since v0.11.4
         */
        getCipher(): CipherNameAndProtocol;
        /**
         * Returns an object repre